{
    "collab_server" : "",
    "contents" : "#' Functions for parsing .bib files\n#' @name bib_parser\n#' @import data.table\n#' @importFrom dplyr if_else\n#' @importFrom dplyr coalesce\n#' @param file.bib \\code{.bib} file.\n#' @param to_sort Include only author, title, year, and date.\n#' @details \\code{bib2DT} returns a \\code{data.table} of the entries in \\code{file.bib}. The function\n#' \\code{reorder_bib} rewrites \\code{file.bib}, to put it in surname, year, title, line number order.\n#' @export bib2DT fread_bib\n\nfread_bib <- function(file.bib){\n  stopifnot(length(file.bib) == 1L)\n  if (!grepl(\"\\\\.bib$\", file.bib)){\n    warning(\"File extension is not '.bib'.\")\n  }\n\n  bib <-\n    read_lines(file.bib) %>%\n    # Avoid testing }\\\\s+$ rather than just == }\n    trimws %>%\n    .[!grepl(\"@Comment\", ., fixed = TRUE)]\n  is_at <- substr(bib, 0L, 1L) == \"@\" #grepl(\"^@\", bib, perl = TRUE)\n  is_closing <- bib == \"}\"\n\n  sep_candidate <- NULL\n  # Can't use = as separator (almost certainly occurs in a URL)\n  # Try these:\n  for (sep_candidate in c(\"\\t\", \"^\", \"|\")){\n    if (!any(grepl(sep_candidate, bib, fixed = TRUE))){\n      sep <- sep_candidate\n      break\n    }\n  }\n  if (is.null(sep_candidate)){\n    stop(\"No suitable separator found for bibliography file. That is, all candidates tried already appeared in the file\")\n  }\n\n  bib_just_key_and_fields <- bib\n  bib_just_key_and_fields[or(is_closing, bib == \"\")] <- NA_character_\n  bib_just_key_and_fields[is_at] <- gsub(\"@\", \"key = \", bib_just_key_and_fields[is_at], fixed = TRUE)\n\n  # Make sure the sep is detected (in case of >author   ={John Daley}<)\n  bib_just_key_and_fields <- gsub(\"={\", \"= {\", bib_just_key_and_fields, fixed = TRUE)\n  bib_just_key_and_fields <- gsub(\" = \", sep_candidate, bib_just_key_and_fields, fixed = TRUE)\n  used_line_nos <- which(!is.na(bib_just_key_and_fields))\n  bib_just_key_and_fields <- bib_just_key_and_fields[!is.na(bib_just_key_and_fields)]\n\n  x <- line_no <- NULL\n  bibDT <- data.table(line_no = used_line_nos,\n                      x = bib_just_key_and_fields)\n\n  field <- value <- NULL\n  bibDT[, c(\"field\", \"value\") := tstrsplit(x, sep, fixed = TRUE)]\n\n  is_key <- NULL\n  bibDT[, is_key := field == \"key\"]\n\n  key_line <- NULL\n  bibDT[, key_line := if_else(is_key, value, NA_character_)]\n  bibDT[, key_line := zoo::na.locf(key_line, na.rm = FALSE)]\n  bibDT <- bibDT[(!is_key)]\n  bibDT[, x := NULL]\n  bibDT[, lapply(.SD, trimws)]\n  bibDT[, key_line := gsub(\",$\", \"\", key_line, perl = TRUE)]\n  bibDT[, c(\"entry_type\", \"key\") := tstrsplit(key_line, \"{\", fixed = TRUE)]\n  bibDT[, field := tolower(trimws(field))]\n  bibDT[, value := gsub(\",$\", \"\", gsub(\"[{}]\", \"\", value, perl = TRUE), perl = TRUE)]\n  \n  dups <- NULL\n  duplicate_fields <-\n    bibDT[, .(dups = anyDuplicated(field)), by = key]\n  \n  if (any(duplicate_fields[[\"dups\"]])){\n    keys <-\n      duplicate_fields %>%\n      .[as.logical(dups)] %>%\n      .[[\"key\"]]\n\n    n_keys <- length(keys)\n\n    if (n_keys <= 5L){\n      top_keys <- keys\n      stop(\"Duplicate fields found in \", paste0(keys, collapse = \" \"), \".\")\n    } else {\n      top_keys <- keys[1:5]\n      if (n_keys == 6L){\n        stop(\"Duplicate fields found in \", paste0(keys, collapse = \" \"), \".\")\n      } else {\n        stop(\"Duplicate fields found in \", paste0(keys, collapse = \" \"), \" and \", n_keys - 5L, \" others.\")\n      }\n    }\n  }\n  bibDT\n}\n\n#' @rdname bib_parser\n\nbib2DT <- function(file.bib, to_sort = FALSE){\n  stopifnot(length(file.bib) == 1L)\n    if (!grepl(\"\\\\.bib$\", file.bib)){\n      warning(\"File extension is not '.bib'.\")\n    }\n\n    bib <-\n      read_lines(file.bib) %>%\n      # Avoid testing }\\\\s+$ rather than just == }\n      trimws %>%\n      .[!grepl(\"@Comment\", ., fixed = TRUE)]\n    is_at <- substr(bib, 0L, 1L) == \"@\" #grepl(\"^@\", bib, perl = TRUE)\n    is_closing <- bib == \"}\"\n    entry_no <- cumsum(is_at)\n  # We make assumptions about the structure\n  # Namely that the closing brace for each entry\n  # is the only character on its own line.\n  n_ats <- sum(is_at)\n  n_closing_braces <- sum(is_closing)\n\n  if (n_ats != n_closing_braces){\n    cat(\"@'s: \", n_ats, \"\\n\",\n        \"}'s: \", n_closing_braces, \"\\n\", sep = \"\")\n    stop(\"Unable to parse: Braces to close a bib entry should be on their own line.\")\n  }\n\n  # All entries must have a nonempty key to be valid\n  if (any(grepl(\"{,\", bib[is_at], fixed = TRUE))){\n    cat(\"At line: \", grep(\"{,\", bib[is_at], fixed = TRUE)[[1]])\n    stop(\"All bib entries must have a non-empty key.\")\n  }\n\n  line_by_entry_no <- cumsum(is_at)\n  keys <- gsub(\"^.*\\\\{(.*),$\", \"\\\\1\", bib[is_at], perl = TRUE)\n\n  if (uniqueN(keys) != n_ats){\n    stop(\"Number of unique keys not equal to number of key entries.\")\n  }\n\n  is_field <-\n    !(is_at | is_closing | bib == \"\")\n\n  extract_field_from <- function(field, from){\n    pattern <- sprintf(\"%s%s%s\", \"^\", field, \"\\\\s+[=]\\\\s+[{](.*)[}],?$\")\n    if_else(grepl(pattern, from, perl = TRUE),\n            gsub(pattern = pattern,\n                 \"\\\\1\",\n                 from), # perl = TRUE slower\n            NA_character_)\n  }\n\n  # CRAN NOTE avoidance\n  Line_no <- Surname <- Year <- annote <- author <- booktitle <- chapter <- crossref <- edition <-\n    editor <- endyear <- howpublished <- institution <- intra_key_line_no <- line_no <-\n    note <- number <- organization <- pages <- publisher <- related <- school <- series <- title <-\n    type <- volume <- Year_as_date <- Date <- NULL\n\n  bib_orig <- field_name <- NULL\n\n  data.table(line_no = seq_along(bib),\n             bib = bib,\n             line_by_entry_no = line_by_entry_no,\n             is_field = is_field,\n             is_closing = is_closing) %>%\n    .[, key := if_else(is_at,\n                       gsub(\"^@[A-Za-z]+\\\\{(.*),$\", \"\\\\1\", bib, perl = TRUE),\n                       NA_character_)] %>%\n    .[, key := zoo::na.locf(key, na.rm = FALSE)] %>%\n    .[, author := extract_field_from(\"author\", bib)] %>%\n    .[, title  := extract_field_from(\"title\", bib)] %>%\n    .[, year   := extract_field_from(\"year\", bib)] %>%\n    .[, date   := extract_field_from(\"date\", bib)] %>%\n    {\n      dot <- .\n      if (!to_sort){\n        out <-\n          dot %>%\n          .[, address := extract_field_from(\"address\", bib)] %>%\n          .[, annote   := extract_field_from(\"annote\", bib)] %>%\n          .[, booktitle   := extract_field_from(\"booktitle\", bib)] %>%\n          .[, booktitle   := extract_field_from(\"booktitle\", bib)] %>%\n          .[, chapter   := extract_field_from(\"chapter\", bib)] %>%\n          .[, crossref   := extract_field_from(\"crossref\", bib)] %>%\n          .[, options   := extract_field_from(\"options\", bib)] %>%\n          .[, related   := extract_field_from(\"related\", bib)] %>%\n          .[, edition   := extract_field_from(\"edition\", bib)] %>%\n          .[, editor   := extract_field_from(\"editor\", bib)] %>%\n          .[, howpublished   := extract_field_from(\"howpublished\", bib)] %>%\n          .[, institution   := extract_field_from(\"institution\", bib)] %>%\n          .[, month   := extract_field_from(\"month\", bib)] %>%\n          .[, note   := extract_field_from(\"note\", bib)] %>%\n          .[, number   := extract_field_from(\"number\", bib)] %>%\n          .[, organization   := extract_field_from(\"organization\", bib)] %>%\n          .[, pages   := extract_field_from(\"pages\", bib)] %>%\n          .[, publisher   := extract_field_from(\"publisher\", bib)] %>%\n          .[, school   := extract_field_from(\"school\", bib)] %>%\n          .[, series   := extract_field_from(\"series\", bib)] %>%\n          .[, type   := extract_field_from(\"type\", bib)] %>%\n          .[, volume   := extract_field_from(\"volume\", bib)] %>%\n          .[, url   := extract_field_from(\"url\", bib)] %>%\n          .[, edition   := extract_field_from(\"edition\", bib)]\n      } else {\n        out <- dot\n      }\n      out\n    } %>%\n    # 1999/2015 --> 1999\n    .[, date := if_else(grepl(\"/\", date, fixed = TRUE),\n                        substr(date, 0, 4),\n                        date)] %>%\n    .[, Year_as_date := if_else(grepl(\"[0-9]{4}\", year),\n                                paste0(year, \"-01-01\"),\n                                year)] %>%\n    .[, Date := coalesce(date, Year_as_date)] %>%\n    .[, Surname := if_else(!is.na(author),\n                           # If protected, just use as-is\n                           # recalling that the outer braces have been removed already\n                           if_else(grepl(\"^[{]\", author, perl = TRUE),\n                                   gsub(\"[{}]\", \"\", author, perl = TRUE),\n                                   # Daley, John\n                                   if_else(grepl(\"^[A-Z][a-z]+,\", author, perl = TRUE),\n                                           author,\n                                           rev_forename_surname_bibtex(author))\n                           ),\n                           # Sort first\n                           NA_character_)] %>%\n    .[, intra_key_line_no := seq_len(.N), by = \"key\"] %>%\n    .[, Line_no := line_no] %>%\n    .[, field_name := gsub(\"[^a-z]\", \"\", gsub(\"[=].*$\", \"\", bib, perl = TRUE), perl = TRUE)] %>%\n    .[, field_name := if_else(is_at, \"AT\", field_name)] %>%\n    .[, field_name := if_else(is_closing, \"}\", field_name)] %>%\n    .[, field_name := factor(field_name,\n                             levels = c(\"AT\", \"author\", \"title\", \"year\", \"date\", \"address\", \"annote\",\n                                        \"booktitle\", \"chapter\", \"crossref\", \"options\", \"related\", \"edition\",\n                                        \"editor\", \"howpublished\", \"institution\", \"month\", \"note\", \"number\",\n                                        \"organization\", \"pages\", \"publisher\", \"school\", \"series\", \"type\",\n                                        \"volume\", \"url\", \"Year_as_date\", \"Date\", \"Surname\", \"intra_key_line_no\",\n                                        \"Line_no\", \"}\"),\n                             ordered = TRUE)] %>%\n    .[, bib_orig := bib] %>%\n    .[, lapply(.SD, zoo::na.locf, na.rm = FALSE, fromLast = FALSE), by = \"key\", .SDcols = author:bib_orig] %>%\n    .[, lapply(.SD, zoo::na.locf, na.rm = FALSE, fromLast = TRUE) , by = \"key\", .SDcols = author:bib_orig] %>%\n    setorder(Surname, Date, title, field_name, Line_no) %>%\n    .[]\n}\n\n#' @rdname bib_parser\n#' @param outfile.bib File to write the reordered bib to. Defaults to \\code{file.bib}.\n#' @export reorder_bib\nreorder_bib <- function(file.bib, outfile.bib = file.bib){\n  out_no <- bib2DT(file.bib, to_sort = TRUE)[[\"Line_no\"]]\n  y <- readLines(file.bib, encoding = \"UTF-8\")\n  out <- y[out_no]\n  outws <- trimws(out)\n  before_equals <- gsub(\"[=].*\", \"\", outws[nchar(outws) > 0], perl = TRUE)\n  \n  if (any(before_equals == shift(before_equals, fill = \"sdfsdfsd\"))) {\n    warning(\"Some entries collapsed:\")\n    print(outws[before_equals == shift(before_equals, fill = \"sdfsdfsd\")])\n  }\n  writeLines(out, outfile.bib, useBytes = TRUE)\n}\n\n",
    "created" : 1493901386438.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2990725122",
    "id" : "DE0422F5",
    "lastKnownWriteTime" : 1493901857,
    "last_content_update" : 1493901857746,
    "path" : "~/grattanReporter/R/bib_parser.R",
    "project_path" : "R/bib_parser.R",
    "properties" : {
    },
    "relative_order" : 26,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}