{
    "collab_server" : "",
    "contents" : "#' Spellchecker for Grattan reports\n#'\n#' @param filename Path to a LaTeX file to check.\n#' @param pre_release Should the document be assumed to be final? Setting to \\code{FALSE} allows function contents to be excluded.\n#' @param ignore.lines Integer vector of lines to ignore (due to possibly spurious errors).\n#' @param known.correct Character vector of patterns known to be correct (which will never be raised by this function).\n#' @param known.wrong Character vector of patterns known to be wrong.\n#' @param bib_files Bibliography files (containing possible clues to misspellings).\n#' @param .report_error A function to provide context to any errors.\n#' @return If the spell check fails, the line at which the first error was detected, with an error message. If the check suceeds, \\code{NULL} invisibly.\n#' @details Uses the \\code{en_AU} hunspell dictionary.\n#' @importFrom hunspell hunspell\n#' @importFrom hunspell dictionary\n#' @import hunspell\n#' @export\n\ncheck_spelling <- function(filename,\n                           pre_release = TRUE,\n                           ignore.lines = NULL,\n                           known.correct = NULL,\n                           known.wrong = NULL,\n                           bib_files,\n                           .report_error){\n  if (missing(.report_error)){\n    .report_error <- function(...) report2console(...)\n  }\n\n  file_path <- dirname(filename)\n  lines <-\n    read_lines(filename)\n\n  if (any(grepl(\"\\\\documentclass\", lines, fixed = TRUE))){\n    lines <- gsub(\"{grattan}\", \"{report}\", lines, fixed = TRUE)\n  }\n\n  if (!is.null(ignore.lines)){\n    lines[ignore.lines] <- \"\"\n  }\n\n  # Never check URLS\n  lines <- replace_nth_LaTeX_argument(lines, command_name = \"url\", replacement = \"url\")\n\n  if (any(grepl(\"\\\\b(?:(?<!(\\\\\\\\))(?:(?:etc)|(?:i\\\\.?e)|(?:e\\\\.?g)))\\\\b\", strip_comments(lines), perl = TRUE))){\n    line_no <- grep(\"\\\\b(?:(?<!(\\\\\\\\))(?:(?:etc)|(?:i\\\\.?e)|(?:e\\\\.?g)))\\\\b\", strip_comments(lines), perl = TRUE)[[1]]\n    .report_error(error_message = \"Use the macros \\\\etc, \\\\ie, and \\\\eg provided for consistent formatting.\",\n                  line_no = line_no,\n                  context = lines[[line_no]])\n    stop(\"Use the commands \\\\ie \\\\eg and \\\\etc rather than hard-coding.\")\n  }\n\n  if (any(grepl(\"^[%] stop_if_present[:]\", lines, perl = TRUE))){\n    extra_known_wrong <-\n      lines[grepl(\"^[%] stop_if_present[:]\", lines, perl = TRUE)] %>%\n      gsub(\"% stop_if_present: \", \"\", ., fixed = TRUE) %>%\n      trimws %>%\n      strsplit(split = \" \", fixed = TRUE) %>%\n      unlist\n\n    known.wrong <- c(known.wrong, extra_known_wrong)\n  }\n\n  # Do not check the bibliography filename\n  lines <- gsub(\"\\\\{.*\\\\.bib\\\\}\",\n                \"\\\\{bibliography.bib\\\\}\",\n                lines)\n\n  if (any(grepl(\"\\\\begin{document}\", lines, fixed = TRUE))){\n    document_starts_at <- grep(\"\\\\begin{document}\", lines, fixed = TRUE)\n    lines_after_begin_document <- lines[-c(1:document_starts_at)]\n  } else {\n    document_starts_at <- 1\n    lines_after_begin_document <- lines\n  }\n\n  if (AND(pre_release,\n          any(grepl(\"% add_to_dictionary:\", lines_after_begin_document, fixed = TRUE)))){\n    .report_error(error_message = \"When pre_release = TRUE, % add_to_dictionary: lines must not be situated outside the document preamble.\")\n    stop(\"When pre_release = TRUE, % add_to_dictionary: lines must not be situated outside the document preamble.\")\n  }\n\n  words_to_add <- NULL\n  if (any(grepl(\"% add_to_dictionary:\", lines, fixed = TRUE))){\n    words_to_add <-\n      lines[grepl(\"% add_to_dictionary: \", lines, fixed = TRUE)] %>%\n      gsub(\"% add_to_dictionary: \", \"\", ., fixed = TRUE) %>%\n      trimws %>%\n      strsplit(split = \" \", fixed = TRUE) %>%\n      unlist\n\n    known.correct <- c(known.correct, words_to_add)\n  }\n\n\n\n\n\n\n  # Check known wrong\n  for (wrong in known.wrong){\n    if (any(grepl(wrong, lines_after_begin_document, perl = TRUE))){\n      line_no <- grep(wrong, lines_after_begin_document, perl = TRUE)[[1]]\n      context <- lines_after_begin_document[[line_no]]\n      .report_error(line_no = line_no + document_starts_at,\n                    context = context,\n                    error_message = paste0(\"'\", wrong, \"' present but prohibited in preamble.\"))\n      stop(paste0(\"'\", wrong, \"' present but prohibited in preamble.\"))\n    }\n  }\n\n  # inputs and includes\n  inputs_in_doc <- length(grep(\"\\\\\\\\(?:(?:input)|(?:include(?!(graphics))))\",\n                               lines_after_begin_document,\n                               perl = TRUE))\n\n  if (inputs_in_doc > 0){\n    inputs <- gsub(\"^\\\\\\\\(?:(?:input)|(?:include(?!(?:graphics))))[{](.*(?:\\\\.tex)?)[}]$\",\n                   \"\\\\1\",\n                   lines_after_begin_document[grepl(\"^\\\\\\\\(?:(?:input)|(?:include(?!(?:graphics))))[{](.*(\\\\.tex)?)[}]$\",\n                                                    lines_after_begin_document,\n                                                    perl = TRUE)],\n                   perl = TRUE)\n\n    if (length(inputs) != inputs_in_doc){\n      stop(\"Unable to parse inputs. Check they are all of the form \\\\input{filename}.\")\n    }\n\n\n    # Recursively check\n    if (length(inputs) > 0){\n      cat(\"Check subfiles:\\n\")\n      for (input in inputs){\n        cat(input, \"\\n\")\n        check_spelling(filename = file.path(file_path,\n                                            paste0(input, \".tex\")),\n                       pre_release = pre_release,\n                       known.correct = known.correct,\n                       known.wrong = known.wrong)\n      }\n    }\n  }\n\n  # Do not check cite keys\n  lines <-\n    gsub(paste0(\"((foot)|(text)|(auto))\",\n                \"cites?\",\n                # optional pre/postnote\n                \"((\",\n                # prenote\n                \"\\\\[\", \"\\\\]\",\n                # postnote\n                \"\\\\[\", \"[^\\\\]]*\", \"\\\\]\",\n                \")?\",\n                # cite key (possibly multiple)\n                # (the multiplicity applies to the prenote as well)\n                \"[{]\", \"[^\\\\}]+\", \"[}])+\",\n\n                collapse = \"\"),\n         \"\\\\1cite\\\\{citation\\\\}\",\n         lines,\n         perl = TRUE)\n\n  # Do not check labels\n  lines <- gsub(paste0(\"(\",\n                       \"\\\\\\\\(([VCvc]?(page)?)|(top)|([Cc]hap))?\",\n                       \"(ref(range)?)|(label)\",\n                       \")\",\n                       \"\\\\{\",\n                       \"([^\\\\}]+)\",\n                       \"\\\\}\"),\n                \"\\\\1\\\\{correct\\\\}\",\n                lines,\n                perl = TRUE)\n\n  # box labels\n  lines <-\n    gsub(paste0(\"(\",\n                \"((small)|(big))box[*]?\",\n                \"[}]\",\n\n                # optional placement parameter\n                # e.g. \\begin{smallbox}[!h]\n                \"(\",\n                \"\\\\[\",\n                # empty optional argument unlikely,\n                # but not for this function to check.\n                \"[!htbpH]*\",\n                \"\\\\]\",\n                \")?\",\n                # title argument\n                \"[{][^\\\\}]+[}]\",\n                # key argument:\n                \"[{]\",\n                \")\", # caputure everything except the actual key\n                \"[^\\\\}]+[}]\"),\n         \"\\\\1box-key\\\\}\",\n         lines,\n         perl = TRUE)\n\n  # itemize enumerate optional arguments\n  lines <-\n    gsub(\"(\\\\\\\\begin[{](?:(?:itemize)|(?:enumerate))[}])(\\\\[[^\\\\]]+\\\\])?\",\n         \"\\\\1\",\n         lines,\n         perl = TRUE)\n\n  # Just completely ignore tabularx tabular table lines\n  for (table_env in c(\"{tabularx}\", \"{tabular}\", \"{table}\")){\n    lines <-\n      if_else(grepl(paste0(\"\\\\begin\", table_env), lines, fixed = TRUE),\n              \"\\\\begin{table-env}\",\n              lines)\n  }\n\n  # Ignore captionsetups\n  lines <- replace_LaTeX_argument(lines, \"captionsetup\", \"\")\n\n  # Valid ordinal patterns are permitted\n  ordinal_pattern <-\n    paste0(\"((?<!1)1(\\\\\\\\textsuperscript\\\\{)?st)\",\n           \"|\",\n           \"((?<!1)2(\\\\\\\\textsuperscript\\\\{)?nd)\",\n           \"|\",\n           \"((?<!1)3(\\\\\\\\textsuperscript\\\\{)?rd)\",\n           \"|\",\n           \"(([04-9]|(1[1-3]))(\\\\\\\\textsuperscript\\\\{)?th)\")\n  stopifnot(identical(grepl(ordinal_pattern,\n                            c(\"3rd\", \"11th\", \"21st\", \"13th\", \"13rd\", \"101st\", \"11st\", \"funding\", \"3\\\\textsuperscript{rd}\"),\n                            perl = TRUE),\n                      c(TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE)))\n\n  lines <-\n    gsub(ordinal_pattern,\n         \"\",\n         lines,\n         perl = TRUE)\n\n  lines <- remove_valid_contractions(lines)\n\n  # Ignore phantoms\n  lines <- replace_LaTeX_argument(lines, command_name = \"phantom\", replacement = \"PHANTOM\")\n  lines <- replace_LaTeX_argument(lines, command_name = \"gls\", replacement = \"ENTRY\")\n  lines <- replace_LaTeX_argument(lines, command_name = \"href\", replacement = \"correct\")\n  # Replace label argument in smallbox etc\n  lines <- replace_nth_LaTeX_argument(lines,\n                                      command_name = \"begin.(?:(?:(?:very)?small)|(?:big))box[*]?[}]\",\n                                      n = 2L,\n                                      replacement = \"box:key\")\n\n  ignore_spelling_in_line_no <-\n    grep(\"^[%] ignore.spelling.in: \", lines, perl = TRUE)\n\n  if (pre_release && not_length0(ignore_spelling_in_line_no)){\n    line_no <- ignore_spelling_in_line_no[1]\n    context <- lines[line_no]\n    .report_error(line_no = line_no,\n                  context = context,\n                  error_message = \"pre_release = TRUE but 'ignore spelling in' line is present.\")\n    stop(\"pre_release = TRUE but 'ignore spelling in' line was present.\")\n  }\n\n  if (!pre_release){\n    commands_to_ignore <-\n      lines[grepl(\"% ignore.spelling.in: \", lines, perl = TRUE)] %>%\n      gsub(\"% ignore.spelling.in: \", \"\", ., perl = TRUE) %>%\n      trimws %>%\n      strsplit(split = \" \", fixed = TRUE) %>%\n      unlist\n\n    for (command in commands_to_ignore){\n      lines <- replace_nth_LaTeX_argument(lines, command_name = command, replacement = \"ignored\")\n    }\n  }\n\n  # Now we can strip comments as all the directives have been used\n  lines <- strip_comments(lines)\n\n  # Treat square brackets as invisible:\n  # e.g. 'urgently phas[e] out' is correct\n  # Need to avoid optional arguments to commands: use the spaces?\n  lines <- rm_editorial_square_brackets(lines)\n\n  lc_govt_pattern <-\n    paste0(\"(?:\",\n           paste0(\"(?:Federal)\",\n                  \"|\",\n                  \"(?:Commonwealth)\",\n                  \"|\",\n                  \"(?:N(?:ew )?S(?:outh )?W(?:ales)?)\",\n                  \"|\",\n                  \"(?:Vic(?:torian?)?)\",\n                  \"|\",\n                  \"(?:Q(?:ueens)?l(?:an)?d)\",\n                  \"|\",\n                  \"(?:S(?:outh )?A(?:ustralian?)?)\",\n                  \"|\",\n                  \"(?:W(?:estern )?A(?:ustralian?)?)\",\n                  \"|\",\n                  \"(?:N(?:orthern? )?T(?:erritory)?)\",\n                  \"|\",\n                  \"(?:A(?:ustralian )?C(?:apital )?T(?:erritory)?)\"),\n           \") government\",\n           \"(?!\\\\s(?:schools?))\")\n\n  if (any(grepl(lc_govt_pattern, lines, perl = TRUE))){\n    line_no <- grep(lc_govt_pattern, lines, perl = TRUE)[[1]]\n    context <- lines[line_no]\n    .report_error(line_no = line_no,\n                  context = context,\n                  error_message = \"Should be upper case G in government.\")\n    stop(\"Wrong case: 'government' should start with uppercase G in this context.\")\n  }\n\n  if (any(grepl(sprintf(\"\\\\b(%s)\\\\b\", wrongly_spelled_words), lines, perl = TRUE))){\n    first_wrong_line_no <-\n      grep(sprintf(\"\\\\b(%s)\\\\b\", wrongly_spelled_words), lines, perl = TRUE) %>%\n      .[1]\n\n    wrongly_spelled_word <-\n      gsub(paste0(\"^.*\\\\b(\", wrongly_spelled_words, \")\\\\b.*$\"),\n           \"\\\\1\",\n           lines[first_wrong_line_no],\n           perl = TRUE)\n\n    if (wrongly_spelled_word == \"percent\"){\n      context <- paste0(lines[first_wrong_line_no], \"\\n\",\n                        \"Use 'per cent', not 'percent'.\")\n    } else {\n      context <- lines[first_wrong_line_no]\n    }\n\n    .report_error(line_no = first_wrong_line_no,\n                  context = lines[first_wrong_line_no],\n                  \"\\n\",\n                  \"\\t\", wrongly_spelled_word)\n    stop(\"Common spelling error detected.\")\n  }\n\n  valid_abbreviations <- extract_validate_abbreviations(lines)\n  \n  words_to_add <- c(valid_abbreviations, paste0(valid_abbreviations, \"s\"), words_to_add)\n\n  parsed <- hunspell(lines, format = \"latex\", dict = dictionary(\"en_GB\"))\n  all_bad_words <- unlist(parsed)\n\n  all_bad_words<- setdiff(all_bad_words,\n                          c(CORRECTLY_SPELLED_WORDS_CASE_SENSITIVE,\n                            correctly_spelled_words,\n                            words_to_add,\n                            known.correct))\n\n  are_misspelt <- vapply(parsed, not_length0, logical(1))\n\n  notes <- NULL\n  if (any(are_misspelt)){\n    good_words <- c(correctly_spelled_words)\n    # Detect big words first\n    good_words <- good_words[order(-nchar(good_words))]\n    gwp <- sprintf(\"(?:\\\\b%s\\\\b)\",\n                   paste0(good_words,\n                          collapse = \"\\\\b)|(?:\\\\b\"))\n\n    GWP <- sprintf(\"(?:\\\\b%s\\\\b)\",\n                   paste0(c(CORRECTLY_SPELLED_WORDS_CASE_SENSITIVE, words_to_add, known.correct),\n                          collapse = \"\\\\b)|(?:\\\\b\"))\n    # Consult the bibliography\n    # if any proper nouns\n    if (!pre_release && !missing(bib_files) && any(grepl(\"^[A-Z]\", all_bad_words, perl = TRUE))){\n      authors_in_bib <-\n        lapply(bib_files, extract_authors_from_bib) %>%\n        unlist\n\n      authors_in_bib_and_doc <-\n        intersect(grep(\"^[A-Z]\", all_bad_words,\n                       value = TRUE, perl = TRUE),\n                  authors_in_bib)\n    } else {\n      authors_in_bib <- authors_in_bib_and_doc <- NULL\n    }\n    assign(\"authors_in_bib_and_doc\", value = authors_in_bib_and_doc, pos = parent.frame())\n\n    for (line_w_misspell in which(are_misspelt)){\n      # If bad words %in% ... don't bother checking\n      bad_words <- setdiff(parsed[[line_w_misspell]],\n                           c(CORRECTLY_SPELLED_WORDS_CASE_SENSITIVE, correctly_spelled_words, words_to_add, known.correct))\n\n      if (!pre_release){\n        if (!is.null(authors_in_bib_and_doc)){\n          bad_words_no_proper_nouns <- setdiff(bad_words, authors_in_bib)\n          bad_words <- bad_words_no_proper_nouns\n        }\n      }\n\n      if (not_length0(bad_words)){\n        bad_line <- lines[[line_w_misspell]]\n        # For timing\n        bad_line_corrected <- gsub(gwp,\n                                   \"\",\n                                   bad_line,\n                                   perl = TRUE,\n                                   ignore.case = TRUE)\n        bad_line_corrected <- gsub(GWP,\n                                   \"\",\n                                   bad_line_corrected,\n                                   perl = TRUE,\n                                   ignore.case = FALSE)\n        recheck <- hunspell(bad_line_corrected,\n                            format = \"latex\",\n                            dict = dictionary(\"en_GB\"))\n\n        if (not_length0(recheck[[1]])){\n          bad_word <- bad_words[[1]]\n          nchar_of_badword <- nchar(bad_word)\n\n          chars_b4_badword <-\n            gsub(sprintf(\"^(.*)(?:%s).*$\", bad_word),\n                 \"\\\\1\",\n                 lines[[line_w_misspell]],\n                 perl = TRUE) %>%\n            nchar\n\n          context <-\n            if (chars_b4_badword + nchar_of_badword < 80){\n              substr(lines[[line_w_misspell]], 0, 80)\n            } else {\n              lines[[line_w_misspell]]\n            }\n\n          .report_error(line_no = line_w_misspell,\n                        context = context,\n                        error_message = paste0(\"Spellcheck failed: '\", bad_word, \"'\"),\n                        extra_cat_post = c(\"\\n\",\n                                           rep(\" \", chars_b4_badword + 5 + nchar(line_w_misspell)),\n                                           rep(\"^\", nchar_of_badword),\n                                           \"\\n\"))\n          stop(\"Spellcheck failed on above line with '\", bad_word, \"'\")\n        }\n      }\n    }\n  }\n\n  # Forgotten full stop.\n  if (any(grepl(\"[a-z]\\\\.[A-Z]\", lines, perl = TRUE))){\n    line_no <- grep(\"[a-z]\\\\.[A-Z]\", lines, perl = TRUE)[[1]]\n    context <- lines[[line_no]]\n    .report_error(line_no = line_no,\n                  context = context,\n                  error_message = \"Missing space between sentence. Likely reason: forgotten space.\")\n    stop(\"Missing space between sentence. Lower-case letter followed by full stop followed by capital letter.\")\n  }\n\n  return(invisible(NULL))\n}\n",
    "created" : 1490492094440.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2026644342",
    "id" : "E10ADD3",
    "lastKnownWriteTime" : 1493885936,
    "last_content_update" : 1493885936863,
    "path" : "~/grattanReporter/R/check_spelling.R",
    "project_path" : "R/check_spelling.R",
    "properties" : {
    },
    "relative_order" : 27,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}